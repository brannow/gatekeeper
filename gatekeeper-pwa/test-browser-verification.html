<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gatekeeper PWA Refactoring Verification</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background: #fafafa;
        }
        .test-result {
            margin: 10px 0;
            padding: 8px;
            border-radius: 4px;
        }
        .pass { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .fail { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .warn { background-color: #fff3cd; color: #856404; border: 1px solid #ffeaa7; }
        .info { background-color: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
        
        .summary {
            margin-top: 30px;
            padding: 20px;
            border-radius: 8px;
            font-weight: bold;
        }
        .summary.success { background-color: #d4edda; color: #155724; }
        .summary.failure { background-color: #f8d7da; color: #721c24; }
        
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px;
        }
        button:hover { background: #0056b3; }
        
        .console-output {
            background: #2d3748;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 5px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
            margin: 10px 0;
        }
        
        .progress {
            width: 100%;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #28a745, #20c997);
            transition: width 0.3s ease;
        }
        
        .metric {
            display: inline-block;
            margin: 5px 10px;
            padding: 5px 10px;
            background: #e9ecef;
            border-radius: 3px;
            font-family: monospace;
            font-size: 12px;
        }
        
        h1 { color: #2c3e50; text-align: center; }
        h2 { color: #34495e; border-bottom: 2px solid #3498db; padding-bottom: 5px; }
        h3 { color: #7f8c8d; margin-top: 20px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîß Gatekeeper PWA Refactoring Verification</h1>
        
        <div class="test-section">
            <h2>Test Controls</h2>
            <button onclick="runFullVerification()">üöÄ Run Full Verification</button>
            <button onclick="runQuickTest()">‚ö° Quick Test</button>
            <button onclick="runPerformanceTest()">üìä Performance Test</button>
            <button onclick="clearResults()">üßπ Clear Results</button>
            
            <div class="progress">
                <div class="progress-bar" id="progressBar" style="width: 0%"></div>
            </div>
            <div id="progressText">Ready to test</div>
        </div>

        <div id="console" class="console-output">
            <div>Gatekeeper PWA Refactoring Verification Test Suite</div>
            <div>Ready to begin testing...</div>
        </div>

        <div id="results">
            <!-- Test results will be populated here -->
        </div>
    </div>

    <script type="module">
        // Global test state
        let testState = {
            totalTests: 0,
            passedTests: 0,
            failedTests: 0,
            startTime: 0,
            results: {}
        };

        // Console output management
        function logToConsole(message, type = 'info') {
            const console = document.getElementById('console');
            const timestamp = new Date().toLocaleTimeString();
            const color = {
                info: '#e2e8f0',
                success: '#68d391',
                error: '#f56565',
                warn: '#ed8936'
            }[type] || '#e2e8f0';
            
            const div = document.createElement('div');
            div.innerHTML = `<span style="color: #a0aec0">[${timestamp}]</span> <span style="color: ${color}">${message}</span>`;
            console.appendChild(div);
            console.scrollTop = console.scrollHeight;
        }

        function updateProgress(percentage, text) {
            document.getElementById('progressBar').style.width = percentage + '%';
            document.getElementById('progressText').textContent = text;
        }

        function addTestResult(testName, passed, details, metrics = {}) {
            testState.totalTests++;
            if (passed) testState.passedTests++;
            else testState.failedTests++;
            
            testState.results[testName] = { passed, details, metrics };
            
            const resultsDiv = document.getElementById('results');
            const testDiv = document.createElement('div');
            testDiv.className = 'test-section';
            
            let metricsHtml = '';
            if (Object.keys(metrics).length > 0) {
                metricsHtml = '<div>' + Object.entries(metrics).map(([key, value]) => 
                    `<span class="metric">${key}: ${value}</span>`
                ).join('') + '</div>';
            }
            
            testDiv.innerHTML = `
                <h3>${testName}</h3>
                <div class="test-result ${passed ? 'pass' : 'fail'}">
                    ${passed ? '‚úÖ' : '‚ùå'} ${details}
                </div>
                ${metricsHtml}
            `;
            
            resultsDiv.appendChild(testDiv);
        }

        // Test 1: Module Import Verification
        async function testModuleImports() {
            logToConsole('Testing module imports...', 'info');
            
            try {
                const modules = [
                    { name: 'PersistentNetworkService', path: './src/services/PersistentNetworkService.js' },
                    { name: 'NetworkEventBus', path: './src/services/NetworkEventBus.js' },
                    { name: 'PersistentMqttAdapter', path: './src/adapters/PersistentMqttAdapter.js' },
                    { name: 'PersistentHttpAdapter', path: './src/adapters/PersistentHttpAdapter.js' }
                ];
                
                const importResults = [];
                
                for (const module of modules) {
                    try {
                        await import(module.path);
                        importResults.push(`‚úì ${module.name}`);
                        logToConsole(`‚úì ${module.name} imported successfully`, 'success');
                    } catch (error) {
                        importResults.push(`‚úó ${module.name}: ${error.message}`);
                        logToConsole(`‚úó ${module.name} import failed: ${error.message}`, 'error');
                    }
                }
                
                const passed = importResults.every(result => result.startsWith('‚úì'));
                const details = passed ? 'All core modules imported successfully' : 'Some modules failed to import';
                
                addTestResult('Module Import Test', passed, details, {
                    'Modules Tested': modules.length,
                    'Import Success': importResults.filter(r => r.startsWith('‚úì')).length
                });
                
                return passed;
            } catch (error) {
                logToConsole(`Module import test failed: ${error.message}`, 'error');
                addTestResult('Module Import Test', false, `Test execution failed: ${error.message}`);
                return false;
            }
        }

        // Test 2: Network Service Creation and Configuration
        async function testNetworkServiceCreation() {
            logToConsole('Testing network service creation...', 'info');
            
            try {
                const { createPersistentNetworkService } = await import('./src/services/PersistentNetworkService.js');
                const service = createPersistentNetworkService();
                
                // Test initialization
                const initStart = performance.now();
                await service.initialize();
                const initTime = performance.now() - initStart;
                
                logToConsole(`‚úì Service initialized in ${initTime.toFixed(2)}ms`, 'success');
                
                // Test configuration update
                const configStart = performance.now();
                await service.updateConfig(
                    { host: '192.168.1.100', port: 80, reachabilityHost: '192.168.1.100' },
                    { host: 'test.mosquitto.org', port: 8081, ssl: true, username: '', password: '' }
                );
                const configTime = performance.now() - configStart;
                
                logToConsole(`‚úì Configuration updated in ${configTime.toFixed(2)}ms`, 'success');
                
                // Check adapters
                const adapters = service.adapters;
                const hasHttp = adapters.some(a => a.method === 'http');
                const hasMqtt = adapters.some(a => a.method === 'mqtt');
                
                // Cleanup
                await service.cleanup();
                
                const passed = service.isInitialized && hasHttp && hasMqtt && configTime < 100;
                const details = passed ? 
                    `Service created with ${adapters.length} adapters (HTTP: ${hasHttp}, MQTT: ${hasMqtt})` :
                    `Service creation issues detected`;
                
                addTestResult('Network Service Creation', passed, details, {
                    'Init Time': `${initTime.toFixed(2)}ms`,
                    'Config Time': `${configTime.toFixed(2)}ms`,
                    'Adapters': adapters.length,
                    'Target Met': configTime < 100 ? 'Yes' : 'No'
                });
                
                return passed;
            } catch (error) {
                logToConsole(`Network service test failed: ${error.message}`, 'error');
                addTestResult('Network Service Creation', false, `Test failed: ${error.message}`);
                return false;
            }
        }

        // Test 3: Event System Verification
        async function testEventSystem() {
            logToConsole('Testing event system...', 'info');
            
            try {
                const { getNetworkEventBus } = await import('./src/services/NetworkEventBus.js');
                const eventBus = getNetworkEventBus();
                
                let eventsReceived = 0;
                const eventTypes = [];
                
                // Subscribe to events
                const subscription = eventBus.subscribe('statusChange', (event) => {
                    eventsReceived++;
                    eventTypes.push(`${event.adapterType}:${event.status}`);
                    logToConsole(`üì® Received event: ${event.adapterType} -> ${event.status}`, 'info');
                });
                
                // Emit test events
                eventBus.emitStatusChange('esp32', 'reachable', 'VerificationTest');
                eventBus.emitStatusChange('mqtt', 'unreachable', 'VerificationTest');
                
                // Wait for events
                await new Promise(resolve => setTimeout(resolve, 50));
                
                // Check event bus stats
                const stats = eventBus.getStats();
                
                // Cleanup
                subscription.unsubscribe();
                const finalStats = eventBus.getStats();
                
                const passed = eventsReceived === 2 && finalStats.totalListeners === 0;
                const details = passed ? 
                    `Event system working correctly (${eventsReceived} events processed)` :
                    `Event system issues detected`;
                
                addTestResult('Event System Test', passed, details, {
                    'Events Sent': 2,
                    'Events Received': eventsReceived,
                    'Cleanup Success': finalStats.totalListeners === 0 ? 'Yes' : 'No',
                    'Event Types': eventTypes.join(', ')
                });
                
                return passed;
            } catch (error) {
                logToConsole(`Event system test failed: ${error.message}`, 'error');
                addTestResult('Event System Test', false, `Test failed: ${error.message}`);
                return false;
            }
        }

        // Test 4: MQTT Adapter Stability
        async function testMqttAdapterStability() {
            logToConsole('Testing MQTT adapter stability...', 'info');
            
            try {
                const { createPersistentMqttAdapter } = await import('./src/adapters/PersistentMqttAdapter.js');
                
                const mqttConfig = {
                    host: 'test.mosquitto.org',
                    port: 8081,
                    ssl: true,
                    username: '',
                    password: ''
                };
                
                const adapter = createPersistentMqttAdapter(mqttConfig);
                await adapter.initialize();
                
                // Get initial client ID
                const initialStatus = adapter.getConfigurationStatus();
                const initialClientId = initialStatus.clientId;
                
                logToConsole(`üìã Initial client ID: ${initialClientId}`, 'info');
                
                // Update config (non-significant change)
                const newConfig = { ...mqttConfig, username: 'testuser' };
                await adapter.updateConfig(newConfig);
                
                // Check client ID persistence
                const updatedStatus = adapter.getConfigurationStatus();
                const updatedClientId = updatedStatus.clientId;
                
                logToConsole(`üìã Updated client ID: ${updatedClientId}`, 'info');
                
                // Cleanup
                await adapter.cleanup();
                
                const clientIdStable = initialClientId === updatedClientId;
                const connectionCountValid = updatedStatus.connectionCount <= 1;
                
                const passed = clientIdStable && connectionCountValid;
                const details = passed ? 
                    'MQTT adapter maintains stable client ID and connection count' :
                    'MQTT adapter stability issues detected';
                
                addTestResult('MQTT Adapter Stability', passed, details, {
                    'Client ID Stable': clientIdStable ? 'Yes' : 'No',
                    'Initial ID': initialClientId.substring(0, 20) + '...',
                    'Updated ID': updatedClientId.substring(0, 20) + '...',
                    'Connection Count': updatedStatus.connectionCount
                });
                
                return passed;
            } catch (error) {
                logToConsole(`MQTT adapter test failed: ${error.message}`, 'error');
                addTestResult('MQTT Adapter Stability', false, `Test failed: ${error.message}`);
                return false;
            }
        }

        // Test 5: Performance Verification
        async function testPerformanceMetrics() {
            logToConsole('Testing performance metrics...', 'info');
            
            try {
                const { createPersistentNetworkService } = await import('./src/services/PersistentNetworkService.js');
                
                let memoryBefore, memoryAfter;
                if (performance.memory) {
                    memoryBefore = performance.memory.usedJSHeapSize;
                }
                
                const configTimes = [];
                
                // Test multiple config updates
                for (let i = 0; i < 5; i++) {
                    const service = createPersistentNetworkService();
                    await service.initialize();
                    
                    const startTime = performance.now();
                    await service.updateConfig(
                        { host: '192.168.1.100', port: 80 + i, reachabilityHost: '192.168.1.100' },
                        { host: 'test.mosquitto.org', port: 8081, ssl: true, username: `user${i}`, password: `pass${i}` }
                    );
                    const configTime = performance.now() - startTime;
                    
                    configTimes.push(configTime);
                    await service.cleanup();
                    
                    logToConsole(`‚è±Ô∏è Config update ${i + 1}: ${configTime.toFixed(2)}ms`, 'info');
                }
                
                if (performance.memory) {
                    memoryAfter = performance.memory.usedJSHeapSize;
                }
                
                const avgConfigTime = configTimes.reduce((a, b) => a + b, 0) / configTimes.length;
                const maxConfigTime = Math.max(...configTimes);
                const targetMet = avgConfigTime < 100;
                
                let memoryStable = true;
                let memoryIncrease = 0;
                if (memoryBefore && memoryAfter) {
                    memoryIncrease = ((memoryAfter - memoryBefore) / memoryBefore) * 100;
                    memoryStable = memoryIncrease < 20; // Less than 20% increase
                }
                
                const passed = targetMet && memoryStable;
                const details = passed ? 
                    `Performance targets met (avg: ${avgConfigTime.toFixed(2)}ms)` :
                    `Performance issues detected`;
                
                addTestResult('Performance Verification', passed, details, {
                    'Avg Config Time': `${avgConfigTime.toFixed(2)}ms`,
                    'Max Config Time': `${maxConfigTime.toFixed(2)}ms`,
                    'Target <100ms': targetMet ? 'Met' : 'Failed',
                    'Memory Change': memoryBefore ? `${memoryIncrease.toFixed(1)}%` : 'N/A',
                    'Memory Stable': memoryStable ? 'Yes' : 'No'
                });
                
                return passed;
            } catch (error) {
                logToConsole(`Performance test failed: ${error.message}`, 'error');
                addTestResult('Performance Verification', false, `Test failed: ${error.message}`);
                return false;
            }
        }

        // Main test functions
        async function runFullVerification() {
            logToConsole('üöÄ Starting full verification test suite...', 'info');
            testState = { totalTests: 0, passedTests: 0, failedTests: 0, startTime: Date.now(), results: {} };
            document.getElementById('results').innerHTML = '';
            
            updateProgress(0, 'Starting verification...');
            
            const tests = [
                { name: 'Module Imports', fn: testModuleImports, weight: 20 },
                { name: 'Network Service', fn: testNetworkServiceCreation, weight: 25 },
                { name: 'Event System', fn: testEventSystem, weight: 20 },
                { name: 'MQTT Stability', fn: testMqttAdapterStability, weight: 20 },
                { name: 'Performance', fn: testPerformanceMetrics, weight: 15 }
            ];
            
            let progress = 0;
            
            for (const test of tests) {
                updateProgress(progress, `Running ${test.name}...`);
                await test.fn();
                progress += test.weight;
                updateProgress(progress, `Completed ${test.name}`);
            }
            
            updateProgress(100, 'Verification complete');
            
            // Generate summary
            const duration = Date.now() - testState.startTime;
            const successRate = (testState.passedTests / testState.totalTests) * 100;
            const overallSuccess = successRate >= 80;
            
            logToConsole(`üìä Verification completed in ${duration}ms`, 'info');
            logToConsole(`‚úÖ Tests passed: ${testState.passedTests}/${testState.totalTests} (${successRate.toFixed(1)}%)`, 
                        overallSuccess ? 'success' : 'error');
            
            // Add summary
            const summaryDiv = document.createElement('div');
            summaryDiv.className = `summary ${overallSuccess ? 'success' : 'failure'}`;
            summaryDiv.innerHTML = `
                <h2>üéØ Verification Summary</h2>
                <p><strong>Overall Result:</strong> ${overallSuccess ? '‚úÖ SUCCESS' : '‚ùå FAILURE'}</p>
                <p><strong>Tests:</strong> ${testState.passedTests}/${testState.totalTests} passed (${successRate.toFixed(1)}%)</p>
                <p><strong>Duration:</strong> ${duration}ms</p>
                <p><strong>Refactoring Goals:</strong> ${overallSuccess ? 'Achieved' : 'Incomplete'}</p>
            `;
            document.getElementById('results').appendChild(summaryDiv);
        }

        async function runQuickTest() {
            logToConsole('‚ö° Running quick test...', 'info');
            document.getElementById('results').innerHTML = '';
            
            await testModuleImports();
            await testEventSystem();
        }

        async function runPerformanceTest() {
            logToConsole('üìä Running performance test...', 'info');
            document.getElementById('results').innerHTML = '';
            
            await testPerformanceMetrics();
        }

        function clearResults() {
            document.getElementById('results').innerHTML = '';
            document.getElementById('console').innerHTML = `
                <div>Gatekeeper PWA Refactoring Verification Test Suite</div>
                <div>Ready to begin testing...</div>
            `;
            updateProgress(0, 'Ready to test');
        }

        // Make functions globally available
        window.runFullVerification = runFullVerification;
        window.runQuickTest = runQuickTest;
        window.runPerformanceTest = runPerformanceTest;
        window.clearResults = clearResults;

        // Auto-run a quick test on load
        logToConsole('Test environment ready. Click "Run Full Verification" to begin.', 'success');
    </script>
</body>
</html>